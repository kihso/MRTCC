%% NREL 5MW data generation.
%
% Calculates parameters for the NREL 5 MW turbine based on CT/CP tables and
% data available in [1].
% The cp and thrust tables for simwindfarm 1.0 and earlier can be found in
% nrel_cp.tsv and nrel_thrust.tsv.
%
% They were generated using wt_perf.exe (see https://wind.nrel.gov/designcodes/simulators/wtperf/)
% New versions of the tables has been added including the scripts to
% generate them. Everything can be found in the wt_perf/ subdirectory.
% See the README.txt file herin to get further details.
%
% Copyright 2009 - Aalborg University
% Author Jacob Grunnet - grunnet@es.aau.dk
% Modified by Mikael Svenstrup
%
%[1] Definition of a 5-MW Reference Wind Turbine for Offshore System Development
% J. Jonkman, S. Butterfield, W. Musial, and G. Scott


clear;

% Want interactive data storage?
interactive=true;


%% Basic wind turbine parameters used in calculations
rho=1.2231;         %Air density
R=63;               %Rotor radius
omega=12.1/60*2*pi;   %Rotor speed used in wt_perf
N=97;               %Gearbox ratio


%% CT and CP tables
%Load CP and thrust files (select which version of WT_Perf data you want
cp = load('wt_perf/nrel_cp_12rmp_v310.oup','-ascii');
F  = load('wt_perf/nrel_ct_12rmp_v310.oup','-ascii');
%cp = load('wt_perf/nrel_cp_12rmp_v305.oup','-ascii');
%F  = load('wt_perf/nrel_ct_12rmp_v305.oup','-ascii');
%cp=load('nrel_cp.tsv','-ascii');
%F=load('nrel_thrust.tsv','-ascii');



omega = cp(1)/60*2*pi;  %Extract the rotational speed that was used in wt_perf
beta=cp(2:end,1);       %Extract pitch
tsr=cp(1,2:end);        %Extract tip speed ratio
cp=cp(2:end,2:end);     %Extract power coefficent
F=F(2:end,2:end);   %Extract Thrust


% You can also load directly from the file generated by WT_Perf, however it
% takes a little more processing. But you do not have to split the data
% into separate files manually.
%filename = 'wt_perf/NRELOffshrBsline5MW_WTPref3.05.oup';
filename = 'wt_perf/NRELOffshrBsline5MW_WTPref310.oup';
%[cp F beta tsr omega]=processWT_Perf_file(filename);

%Convert thrust force to N (can also be changed in a setting in the .wtp file)
kN_to_N = 1000;
F=F*kN_to_N;


%Find the few unconverged cases from WT_Perf and do simple interpolation to
%fix the table
[cp F] = fix_cp_table(cp,false,F,beta,tsr);


u=omega*R./tsr;     %Derived wind speeds

%Compute thrust coefficient for each TSR
%F = rho/2 * pi *R^2 * v^2 * Ct
% Ct = 2*F /(rho * pi *R^2 *v^2)
ct =  2 * F / (rho*pi*R^2) .* repmat(tsr,length(beta),1).^2 / (omega^2 * R^2);


%%This is the same
%for i=1:size(F,2)
%    ct(:,i)=F(:,i)./(.5*rho*u(i)^2*pi*R^2);
%end

%% Make ENV and WT structure
env.rho=rho;

%CP and CT tables
wt.cp.table=cp;
wt.cp.beta=beta;
wt.cp.tsr=tsr;

wt.ct.table=ct;
wt.ct.beta=beta;
wt.ct.tsr=tsr;

%Blade properties
wt.blade.mass=17740; % [kg]
wt.blade.inertia=11776047; %[kgm^2]
wt.blade.length=61.5;% [m]

%Hub properties
wt.hub.height=90; %[m]
wt.hub.inertia=115926; %[kgm^2]
wt.hub.radius=1.5; %[m]
wt.hub.mass=56780; % [kg]

%Nacelle properties
wt.nac.mass=240000; %[kg]

%Tower properties
wt.tower.mass=347462; %[kg]
wt.tower.height=87.6; %[m]
wt.tower.damp=.08;
wt.tower.eigfreq=(.32)/(sqrt(1-wt.tower.damp^2)); %calculate undamped freq

%Generator properties
wt.gen.inertia=534.116; %[kgmÂ²] around HSS
wt.gen.N=N; % Gear ratio
wt.gen.effeciency=0.944;
wt.gen.ratedspeed=1173.7*2*pi/60; %[rad/s]
wt.gen.timeconstant=0.1; %[s]

%Rotor properties (LSS)
wt.rotor.spring=867637000; % [Nm/rad]
wt.rotor.damp=6215000; % [Nm/(rad*s)]
wt.rotor.radius=wt.hub.radius+wt.blade.length; % [m]
wt.rotor.inertia=wt.hub.inertia+3*wt.blade.inertia; % [kgm^2]
wt.rotor.mass=wt.hub.mass+3*wt.blade.mass; %[kg]
wt.rotor.ratedspeed=12.1*pi/30 ;% [rad/s]

%Pitch actuator properties
wt.pitch.delay=0.05;
wt.pitch.tau=0.05;
wt.pitch.K=10;

%Tower top properties
wt.top.mass=wt.nac.mass+wt.rotor.mass;



%% Torque controller
timestep=0.0125; %controller time step
fcorner=.25;  %filter corner frequency
alpha=exp(-2*pi*timestep*fcorner); %filter parameter.

%Torque control regions
wg_rated=1173.7*pi/30; %[rad/s]
wg_15=670*pi/30;
wg_2=871*pi/30;
wg_25=1100*pi/30;
wg_3=1161.963*pi/30;

%Region 2 (optimal region)
A=pi*R^2; %area of dish m2
cp_max=max(max(cp));% %maximum cp
[i,j]=find(cp==cp_max,1);
tsr_opt=tsr(j); %Optimal tsr
beta_opt=beta(i); %optimal pitch
wg_2_rot=wg_2/N; %rotor speed at region 2 transition
k_M=.5*rho*R^3*A*cp_max/(tsr_opt^3*N^3); %Optimal generator torque coefficient
M_2=k_M*wg_2^2; %generator torque at region start of 2
M_25=k_M*wg_25^2; %generator torque at region start of2.5

%Rated torque and power
M_rated=43093.55; %[Nm]
P_rated=M_rated*wg_rated;

%Resolution for table generation
wg_res=.1;

%Generator speed points
wg_r=0:wg_res:wg_rated;

%Region 1
wg1r=wg_r(wg_r<wg_15);

%Region 1.5
temp=wg_r(wg_r>wg_15);
wg15r=temp(temp<wg_2);

%Region 2
temp=wg_r(wg_r>wg_2);
wg2r=temp(temp<wg_25);

%Region 2.5
wg25r=wg_r(wg_r>wg_25);

%Torque table generation
M_r1=0*wg1r; %Region 1
M_r15=M_2/(wg_2-wg_15)*(wg15r-wg_15); %region 1.5
M_r2=k_M*wg2r.^2; %region 2
M_r25=(P_rated/wg_3-M_25)/(wg_3-wg_25)*(wg25r-wg_25)+M_25; %region 2.5

M_r=[M_r1 M_r15 M_r2 M_r25]; %Full table


%% pitch controller

%Apparent inertia at the low speed shaft
I_DT=N^2*wt.gen.inertia+wt.rotor.inertia;

%Control specification parameters
damp=.7; %damping facator
wund=.6; %Undamped eigenfrequency
w_rot_r=12.1*pi/30; %Optimal rotor rate


%% Calculate lookup matrix for gain scheduling

%Power levels for gain scheduling matrix
lvls=[1e6 2e6 3e6 4e6 5e6 5.29e6];

%reduce the pitch range for gs to an approimatly linear region of dp/dbeta
b_ind = find(beta==0):find(beta==25);
beta_gs=beta(b_ind);

%Calculate partial derivatives of power with respect to tsr and pitch
invtsr=tsr.^-1; %inversion of tsr

%Power coefficient depending on tsr
K_P=.5*rho*A*(wt.rotor.ratedspeed*R.*invtsr).^3;
for i=1:length(K_P)
    P(:,i)=K_P(i)*cp(:,i);
end
%assuming .1 and .2 resolution of cp/ct
[dtsr,dbeta]=gradient(P,.1,.2*pi/180);

%Colors for plots
c='bgrcmyk';
%Calculate the gain scheduling values based on power level curves
for i=1:length(lvls)
    %Level curve cor lvl(i)
    lc=contourc(tsr,beta_gs,P(b_ind,:),[lvls(i) lvls(i)]);
    
    %If the cp curve contains data for beta below the value of max cp, i.e.
    %the beta<0 for the NREL5MW turbine. Then there may be contour lines
    %both above and below the top of the Cp curve. It is only the one above
    %that should be used, because this will be the operating points. It is
    %computationally relatively difficult to calculate which level curve
    %should be used, although you can easily see it on the figure
    %contourf(tsr,beta_gs,P(b_ind,:),[lvls(i) lvls(i)])
    %Therefore we just take the longest level curve.
    idx_start =find(lc(1,:)==lvls(i)); %Start of each level set
    [lc_length , idx] = max(lc(2,idx_start)); %Find the max length and which one it is
    lc = lc(:, idx_start(idx) + 0:lc_length);
    
    %Spline interpolation of dp/dbeta over the level curve points
    dbl=interp2(tsr,beta,dbeta,lc(1,2:end),lc(2,2:end),'spline');
    %Fit the curve to a first order polynomial
    pdbl=polyfit(lc(2,2:end),dbl,1);
    
    %Populate the gain scheduling table based on the polyvals
    gs(i,:)=polyval(pdbl,beta);
    
    
    %Uncomment to plot graphs
    %figure(1)
    %plot(lc(2,2:end),dbl,['*' c(i)])
    %hold on
    %plot(beta_gs,polyval(pdbl,beta_gs),c(i));
    %figure(2)
    %hold on
    %plot(lc(2,2:end),lc(1,2:end),c(i));
    
    
end

%Extract base gain
dpdv=gs(end,b_ind(1));
%Scale matrix with base gain
gs=(gs/dpdv); %MS: why? This is strange. The value of dpdv is around 0 (relatively), so it could have a huge impact if it is positive or negative. Maybe it cancels out because it is included in the calculation of Kp and Ki below.
%Hack! Make the gs independent of power level by using gains for full power
gs=repmat(gs(end,:),size(gs,1),1);

%Uncomment to use values from NREL paper
%dpdv=-28.24e6;
%beta_k=6.302336; %Pitch angle causing doubling of power
%beta_r=0:.1:90;
%beta=beta_r;
%gk=1+(beta_r-beta_opt)/beta_k;
%gs=repmat(gk,size(gs,1),1);

%Calculate base propertional and integral gains
Kp=2*I_DT*w_rot_r*damp*wund/(N*dpdv);
Ki=I_DT*w_rot_r*wund^2/(N*dpdv);


%% Fill out ctrl part of data struct

%Pitch controller
wt.ctrl.pitch.beta=beta;
wt.ctrl.pitch.pwr=lvls;
wt.ctrl.pitch.gs=gs;
wt.ctrl.pitch.Pgain=Kp;
wt.ctrl.pitch.Igain=Ki;
wt.ctrl.pitch.ratelim=8;
wt.ctrl.pitch.ulim=90;
wt.ctrl.pitch.llim=0;


%Torque controller
wt.ctrl.torq.beta=0;
wt.ctrl.torq.wg=wg_r;
wt.ctrl.torq.M=M_r;
wt.ctrl.torq.r3=wg_3;
wt.ctrl.torq.lim=474502.91;
wt.ctrl.torq.ratelim=15e3;

%Other control parameters
wt.ctrl.gen.rated=wg_rated;
wt.ctrl.p_rated=P_rated; %find val
wt.ctrl.alpha=alpha;
wt.ctrl.Ts=timestep;
wt.ctrl.gen.effeciency=0.94;


%Measurement system values
%Fix these values
wt.meas.Ts=timestep;
wt.meas.ballufres=.01;
wt.meas.rotres=.001;
wt.meas.aneres=.001;
wt.meas.genres=.01;
wt.meas.delay=0.01;
wt.meas.rottau=0.01;
wt.meas.gentau=0.01;

%Save public values
pub.rotor.radius=wt.rotor.radius;
pub.rated=5e6; %5MW
pub.rotor.Nslope=10; %Blade wholer curve slope
pub.rotor.Mult=10e10;% Ultimate load (find a value)
pub.tower.Nslope=4; %Steel slope
pub.tower.Mult=10e10;% Ultimate load (find a value)
pub.shaft.Nslope=4; %Steel slope, but is that true for torsion?
pub.shaft.Mult=10e10;% Ultimate load (find a value)


save NREL5MW.mat wt env pub


%Replace data in a simulink diagram with the new data
if(interactive)
    p.wt=wt;
    p.env=env;
    p.public=pub;
    disp('Select and highlight the turbine block which you want to update parameters for and press enter');
    disp('Remember to unlock the library');
    pause
    set_param(gcb,'UserData',p);
    set_param(gcb,'UserDataPersistent','on');
end


%Uncomment for additional plots
figure(3)
hold off
[lc,h]=contour(u(20:100),beta(1:125),P(1:125,20:100),[1e6 2e6 3e6 4e6 5.29e6]);
hold on
u_3=[11.4 12:1:25];
invu_3=u_3.^-1;
beta_3=[0 3.83 6.6 8.7 10.45 12.06 13.54 14.92 16.23 17.47 18.7 19.94 21.18 22.35 23.47];
plot3(u_3,beta_3,ones(15,1)*5.3e6,'*');


figure(4)
hold off

[dtsr,dbeta]=gradient(P,.1,.2*pi/180);
ind_3=sub2ind(size(P),round(1+beta_3/.2),round(wt.rotor.ratedspeed*R.*invu_3/.1));
P_3=P(ind_3);
dpdb=dbeta(ind_3);
Pdpdb=polyfit(beta_3,dpdb,1);

Ndpdb=[28.23 43.73 51.66 58.44 64.44 70.46 76.53 83.94 90.67 94.71 99.04 105.90 114.3 120.2 125.3]*-1e6;
NPdpdb=polyfit(beta_3,Ndpdb,1);

plot(beta_3,polyval(Pdpdb,beta_3),'r')
hold on
plot(beta_3,dpdb,'r*')

plot(beta_3,polyval(NPdpdb,beta_3),'g')
plot(beta_3,Ndpdb,'g*')